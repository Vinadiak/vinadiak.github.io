---
layout: post
title: 学习TCP/IP、HTTP和HTTPS
description: TCP/IP协议、HTTP和HTTPS协议
categories:  协议
---



<!-- more -->

TCP/IP工作流程：

1.在源主机上，主机将应用层一串数据流传送给传输层

2.传输层将数据进行分组，并加上TCP报头形成TCP段，传到网络层

3.网络层在TCP段中附加源和目的的IP地址，生成一个IP数据包，并将IP数据包给链路层

4.链路层在其MAC帧上的数据包上添加IP数据包，附加源和目的的MAC地址和帧头，并将根据目的MAC地址发往目标主机

在目的主机上：

1.链路层将MAC地址帧头去掉，并将IP数据包交给网络层

2.网络层检查ip报头，如果报头的校验值和计算结果不一致，则丢弃该数据包；若校验结果和计算结果一致，则去掉ip报头，将TCP段传交给传输层

3.传输层检查顺序号，判断是否为正确的TCP分组，然后检查报头数据。若正确，则向源主机发确认消息；若不正确或丢包，则向源主机要求重发消息。

4.在目的主机，传输层去掉TCP报头，将排好顺序的分组组成应用数据流送给应用程序。这样目的主机接收到来自源主机的字节流，就像是直接接受到一样。



1.建立协议（三次握手）

（1）客户端发送一个带syn标志的TCP报文到服务器，seq=X（一般为1），标志为syn

（2）服务器回应客户端，这个报文带ACK标志和SYN标志，seq=y，ack=x+1，SYN=1,ACK=1

（3）客户端必须回应服务器一个ACK标志的报文 ACK=1

 ![](/images/character3/TCP1.png)

进行三次握手的原因：

1.确保对方主机是接受到TCP报文的，防止一些无用的连接增加服务器开销以及防止已失效的连接请求报文又突然传到服务端，产生错误。

2.网络传输是有延迟的，建立三次握手可以避免因为主机突然中断而传送不了消息导致另一台主机认为连接一直是开启的，同时第三次握手可以保证对方主机发送过来的消息是可以接受到的。





四次挥手：

 ![](/images/character3/TCP2.png)

1.客户端想要释放连接，发送一段TCP报文，TCP报文FIN标志为1，seq的标志为u，客户端进入FIN-WAIT-1状态



2.服务器端接收到从客户端发出的TCP报文后，确认客户端想要释放连接，随后服务端进入CLOSE-WAIT状态，随后发送一段TCP报文

TCP报文的ACK标志为1，seq=v,ack=u+1

客户端接收到TCP报文后，进入FIN-WAIT-2状态

3.服务器端再次向客户端发出报文，报文的FIN标志位为1，Seq=U+1，ACK=W+1，服务器端进入LAST-ACK状态

4.客户端接受到报文后，进入TIME-WAIT状态，并发送一段TCP报文，标志位为ACK，Seq=u+1,ack=W+1，随后进入等待2MSL状态，等待2MSL状态之后进入CLOSED状态

MSL状态表示等待一段TCP报文存活周期，2MSL是即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。





为什么要等待2MSL：

因为客户端要等待服务器进入CLOSED状态，由此正式确认关闭服务器到客户端的连接



进入2MSL状态再次向客户端发送报文则客户端再次重发确认报文，并重置计时器等待2MSL。



为什么要三次握手，而挥手要四次

TCP建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。

即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。

TCP释放连接时之所以需要“四次挥手”,是因为网络不可靠的，你无法确认与ACK确认接收报文和FIN释放连接报文对面是接收到的，所以需要四次挥手



TCP保证可靠性主要依靠下面7种机制：
1、检验和
TCP检验和的计算与UDP一样，在计算时要加上12byte的伪首部，检验范围包括TCP首部及数据部分，但是UDP的检验和字段为可选的，而TCP中是必须有的。计算方法为：在发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如最终结果为检验字段所有位是全1则正确（UDP中为0是正确），否则存在错误。
2、序列号
TCP将每个字节的数据都进行了编号，这就是序列号。
序列号的作用：
a、保证可靠性（当接收到的数据总少了某个序号的数据时，能马上知道）
b、保证数据的按序到达
c、提高效率，可实现多次发送，一次确认
d、去除重复数据
数据传输过程中的确认应答处理、重发控制以及重复控制等功能都可以通过序列号来实现
3、确认应答机制（ACK）
TCP通过确认应答机制实现可靠的数据传输。在TCP的首部中有一个标志位——ACK，此标志位表示确认号是否有效。接收方对于按序到达的数据会进行确认，当标志位ACK=1时确认首部的确认字段有效。进行确认时，确认字段值表示这个值之前的数据都已经按序到达了。而发送方如果收到了已发送的数据的确认报文，则继续传输下一部分数据；而如果等待了一定时间还没有收到确认报文就会启动重传机制。
正常情况下的应答机制：

4、超时重传机制
当报文发出后在一定的时间内未收到接收方的确认，发送方就会进行重传（通常是在发出报文段后设定一个闹钟，到点了还没有收到应答则进行重传），其基本过程如下：

当接收方接收到重复的数据时就将其丢掉，重新发送ACK。而要识别出重复的数据，就要用到前面提到的序列号了，利用序列号很容易就可以做到去重的效果。
重传时间的确定：报文段发出到收到应答中间有一个报文段的往返时间RTT，显然超时重传时间RTO会略大于这个RTT，TCP会根据网络情况动态的计算RTT，即RTO是不断变化的。在Linux中，超时以500ms为单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。其规律为：如果重发一次仍得不到应答，就等待2*500ms后再进行重传，如果仍然得不到应答就等待4*500ms后重传，依次类推，以指数形式递增，重传次数累计到一定次数后，TCP认为网络或对端主机出现异常，就会强行关闭连接

5。流量控制

接收端处理数据的速度是有限的，如果发送方发送数据的速度过快，导致接收端的缓冲区满，而发送方继续发送，就会造成丢包，继而引起丢包重传等一系列连锁反应。
因此TCP支持根据接收端的处理能力，来决定发送端的发送速度，这个机制叫做流量控制。
在TCP报文段首部中有一个16位窗口长度，当接收端接收到发送方的数据后，在应答报文ACK中就将自身缓冲区的剩余大小，放入16窗口大小中。这个大小随数据传输情况而变，窗口越大，网络吞吐量越高，而一旦接收方发现自身的缓冲区快满了，就将窗口设置为更小的值通知发送方。如果缓冲区满，就将窗口置为0，发送方收到后就不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端。
其过程如下：

7、拥塞控制
流量控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。
为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。
此处引入一个拥塞窗口：
发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。
慢启动：在启动初期以指数增长方式增长；设置一个慢启动的阈值，当以指数增长达到阈值时就停止指数增长，按照线性增长方式增加；线性增长达到网络拥塞时立即“乘法减小”，拥塞窗口置回1，进行新一轮的“慢启动”，同时新一轮的阈值变为原来的一半。
“慢启动”机制可用图表示：







### TCP和UDP的区别



 ![](/images/character3/TCP3.png)

TCP：HTTP、DNS、FTP

UDP：SNMP、TFTP

### HTTP和HTTPS的区别

#### HTTP的特点：

* http协议支持客户端/服务端模式，也是一种请求/响应模式的协议
* 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
* 灵活：http允许传输任意类型的数据对象。传输的类型由Content-type标记
* 无连接：处理完请求后就断开连接，cookie和session是为了弥补这种缺点
* 无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的消息，则必须重传



### HTTPS的特点：

SSL使用了安全套接字层，SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持

传输数据流程：

 ![](/images/character3/TCP4.png)

1.客户端向服务端请求https连接

2.服务返回证书（包含公钥）给客户端

3.客户端开始协商SSL连接的安全等级

4.客户端根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话加密，传送给网站

5 服务器利用自己的私钥解密出会话密钥

6 服务器利用会话密钥加密与客户端之间的通信

