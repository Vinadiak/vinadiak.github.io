---
layout: post
title: 深入理解操作系统
description: 学会pwn必须对操作系统有全面的理解
categories:  操作系统
---



<!-- more -->




# 深入理解操作系统（一）

### 操作系统加载程序过程：

![](/images/character4/system1.png)


* 预处理阶段：预处理器根据cpp字符以字符#开头的命令匹配文件告诉寄存器,将文件内容插入到程序文本中,重新生成文件

* 编译阶段：编译器将hello.i翻译成hello.s,包含一个汇编程序

* 汇编阶段：将hello.s翻译成机器语言并打包成可重定位目标程序
* 链接阶段：hello程序调用了printf程序,printf函数存在一个printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种形式合并到hello.o文件中,链接器就处理这种合并,就得到hello程序加载到内存中



了解编译系统是如何工作的好处：

* 优化程序性能
* 理解链接时出现的错误
* 避免安全漏洞



### 系统的硬件组成

1. 总线

   总线是贯穿整个系统的电子管道，用来传送定长的字节块，也就是字，字长是一个基本的系统参数，现在机器字长要么是32位，要么是64位

2. I/O设备

   系统与外部世界的联系通道，每个设备通过一个控制器或适配器与IO总线相连，控制器是电路板上的芯片组，适配器是主板插槽上的一张卡

3. 主存

   临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。物理上，主存是一组动态随机存储器芯片组成的。逻辑上，存储器是一个线性的字节数组，**每个字节都有唯一的地址** 

4. CPU

​        中央处理器，是解释或执行在主存中指令的殷勤。处理器的核心是一个大小为一个字的存储设备，称为程序计数器。PC永远都指向主存中的某条机器指令。

​        处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，更新PC，指向下一条指令。这些操作都围绕着主存、寄存器文件和算术/逻辑单元（ALU）进行，ALU计算新的数据和地址值。

* 加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容。
* 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原来的内容。
* 操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并存放到一个寄存器中，以覆盖该寄存器中原来的内容。
* 跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器中，以覆盖PC中原来的值



### 系统运行hello程序

流程：从shell中输入“./hello" 输出Hello World

流程一：I/O设备将用户输入的字符hello通过总线读入寄存器并送到内存中。

![](/images/character4/system2.png)


流程二：当按下Enter键，处理器将hello程序和程序数据从磁盘读入到内存中，利用DMA技术可以不经过处理器
![](/images/character4/system3.png)


流程三：CPU处理指令，当运行到printf后，指令将hello，world从主内复制到寄存器文件，并从寄存器文件复制到显示设备，最终显示屏幕中。


![](/images/character4/system4.png)


### 进程

进程是操作系统对一个正在运行的程序的一种抽象，在一个系统上可以同时运行多个进程，并发运行是指一个进程的指令和另一个进程的指令是交错执行的。通过处理器在进程间切换来实现的，这种切换称为上下文切换。存包的内容有PC和寄存器文件的当前值，以及是主存的内容。



### 线程

一个进程可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。



### 虚拟内存

虚拟内存是抽象的概念，对所有进程来说看到内存都是一致的，称为虚拟地址空间。



### 系统之间利用网络通信

从系统上来看，网络可视为一个I/O设备，当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器





### 并发和并行

并发：一个同时具有多个活动的系统

并行指的是用并发来使一个系统运行得更快



#### 线程级并发

使用线程可以能够让一个进程中执行多个控制流。

超线程，有时称为同时多线程是一项允许一个cpu执行多个控制流的技术。它涉及CPU某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份。



指令级并发

在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令集执行。



### 进程与线程的区别

1. 进程是资源分配最小单位，线程是程序执行的最小单位；
2. 进程有自己独立的地址空间，每启动一个进程，系统都会为其分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据；
3. CPU切换一个线程比切换进程花费小；
4. 创建一个线程比进程开销小；
5. 线程占用的资源要⽐进程少很多。
6. 线程之间通信更方便，同一个进程下，线程共享全局变量，静态变量等数据，进程之间的通信需要以通信的方式（IPC）进行；（但多线程程序处理好同步与互斥是个难点）
7. 多进程程序更安全，生命力更强，一个进程死掉不会对另一个进程造成影响（源于有独立的地址空间），多线程程序更不易维护，一个线程死掉，整个进程就死掉了（因为共享地址空间）；
8. 进程对资源保护要求高，开销大，效率相对较低，线程资源保护要求不高，但开销小，效率高，可频繁切换；
